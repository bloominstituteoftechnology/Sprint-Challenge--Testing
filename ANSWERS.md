<!-- Answers to the Short Answer Essay Questions go here -->

1. In Mocha, what are the differences between `before`, `after`, `beforeEach`, and `afterEach`? When do they run? What are they used for?
- All four of these are described as "hooks," which are ostensibly similar to the lifecycle hooks in React. All four of them are used inside of describe blocks, and all four take a callback as a parameter; however, they differ in where they run, and how many items they run on. For example, both before and beforeEach run their code block in their callback before the tests have been run in the describe, but before will run before all of the tests run in the block, whereas beforeEach will run right before each individual test runs. After and afterEach are very similar in that they both run after the tests, but after runs once all the tests have been completed, and afterEach runs once for every time a single test is completed.

2. What is the point of Test Driven Development? What do you personally think about this approach?
- It seems to me, with my limited knowledge of the subject at this point in time, that TDD is akin to wireframing, but with tests being built as well as the general structure of the app being defined. To elaborate, when you are designing tests first, you are blueprinting what the app is going to look like, how it's going to function, etc. long before the app itself has been written. This seems to lend itself to helping you clearly define what each small segment of functionality in your app should do before any of it is written, offering you a guide for actually implementing the app.

- Personally, I would not design something with tests first, at least with my current level of exposure to it. I'm all for laying out what your app will look like/do in advance as a guide, but I think you have much more freedom by writing the tests after the bulk of the code. Also, the idea of writing the tests first doesn't feel like it follows the creative pathways that my brain seems to travel along.

3. What is a `spy` in `sinon`? How do we use it to effectively test a `callback`?
- Admittedly, this is one of the concepts I'm the most fuzzy about this week. I could tell you how to implement a spy the way we have in our repos from the week, but explaining the mechanics of it is another story. As I currently understand it, a spy is a method provided by the Sinon library that allows you to simulate the functionality you would expect from a fully working application. It appears that you can substitute it in the place of a callback when testing a function that requires one, although I could not tell you exactly why. The spy keeps track of a few parameters useful for testing, such as how many times a function has been run, what is 'this' binded to, and what errors have surfaced. The spy can be used either as an anonymous function by storing its execution in a variable with no parameters, or by calling it directly and passing in an object and a method which will now be "spied" on by the spy.