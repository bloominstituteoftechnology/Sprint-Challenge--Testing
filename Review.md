# Please answer the following questions

1.  In Jest, what are the differences between `describe()` and `it()` globals, and what are good uses for them?
    Describe is a global function used to logically group a series of test together. It is used mainly for readability, both for developers reviewing the source code of your tests, and the tests output, which will show whatever you have called the testing 'suite' before it shows the individual tests. The it global is where you actually build and run your tests. It is the equivalent of test() in other languages, and is the backbone of Jest's testing functionality
2.  What is the point of `Test Driven Development`? What do you think about this approach?
    In my understanding, the point of TDD is to build code which can easily be broken down into testable parts. This also means that if the code can be broken down into testable parts, then it can be broken down into re-usable parts, which is a helpful side effect which allows for DRY code, and which enforces our understanding of the individual pieces of an application. The more we understand the component pieces, the more clearly we understand the app as a whole, so TDD prevents us from simply writing overly complex code without realizing it. I like it and appreciate the principles behind it, though I'll admit it seems a little tedious at times for the smaller apps we've been building thus far. 
3.  What are `mocks`? What are a good use case for them?
    Mocks are contrived examples of state, or props (or both), which are built in order to unit test a component, or function, without any kind of outside influence or without requiring integration with another component. Mocks allow us to specifically control the input and state in which a part of our code runs, in order to eliminate as many variables as possible and just test a specific part of an application. Mocks can also be used to simulate functions which are generally passed in, or inherited by a component. 
4.  Mention three types of tests.
    Unit testing is where we test a small, individual part of an application. It is helpful, and good design, if these units are pure functions/components and perform one task well. Anotehr type of testing is integration testing, where two such smaller units are tested to see if their interaction goes as planned, without any unintended side effects or miscommunication. A third is snapshot testing, which in the case of react components creates a file with all the output which that component creates at the time of the test. Future tests are then compared against that file, and if they are the same, it passes, if it's different, it fails. This is great to test against unexpected regressions and to ensure that the overall behavior of the component hasnt changed as a result of future testing, but it is also a very blunt tool which doesn't help much in terms of actually testing the inner workings of a component. 